#!/usr/bin/env python3
"""
üî•üíÄ ULTRA EKSTREMALNE ROZPIERDALANIE SYSTEMU üíÄüî•
Ten test ma za zadanie kompletnie rozjechaƒá system na wszystkich mo≈ºliwych frontach!
UWAGA: To jest test destrukcyjny - mo≈ºe uszkodziƒá system!
"""

import asyncio
import time
import threading
import multiprocessing
import random
import json
import sqlite3
import psutil
import gc
from concurrent.futures import ThreadPoolExecutor, ProcessPoolExecutor, as_completed
from datetime import datetime
import sys
import os
import traceback
import signal

# Dodaj ≈õcie≈ºkƒô do modu≈Ç√≥w
sys.path.append('.')
sys.path.append('./core')

from core.hierarchical_memory import HierarchicalMemorySystem
from core.cognitive_engine import CognitiveEngine
from core.research import autonauka
from core.memory import memory_manager
from core.config import *

class UltraExtremeStressTest:
    def __init__(self):
        self.results = {
            'destruction_level': 0,  # 0-100 jak bardzo system zosta≈Ç zniszczony
            'operations_completed': 0,
            'operations_failed': 0,
            'memory_leaks': [],
            'crashes': [],
            'database_corruption': False,
            'system_recovery_time': 0,
            'max_memory_usage': 0,
            'max_cpu_usage': 0,
            'start_time': time.time(),
            'test_phases': []
        }
        
        # Inicjalizuj systemy
        try:
            self.hm_system = HierarchicalMemorySystem()
            self.cognitive = CognitiveEngine()
            self.memory_mgr = memory_manager
            print("üî• SYSTEMY ZAINICJALIZOWANE - PRZYGOTOWANIE DO DESTRUKCJI!")
        except Exception as e:
            print(f"üíÄ B≈ÅƒÑD KRYTYCZNY ju≈º przy inicjalizacji: {e}")
            self.results['crashes'].append(f"Init crash: {e}")

    def generate_chaos_data(self, intensity="EXTREME"):
        """Generuje skrajnie chaotyczne dane o r√≥≈ºnych poziomach destrukcji"""
        
        if intensity == "NORMAL":
            return random.choice([
                "Test message",
                "Simple query", 
                "Hello world",
                "Basic data"
            ])
        elif intensity == "HEAVY":
            return random.choice([
                "A" * random.randint(1000, 5000),  # D≈Çugie stringi
                "üî•üí•üöÄ" * random.randint(100, 500),  # Emoji spam
                "SELECT * FROM " + "x" * 1000,  # SQL injection attempt
                "\n\r\t" * random.randint(50, 200),  # Whitespace chaos
                "{'malformed': json, 'test': " + str(random.random()),  # Broken JSON
                "\\x00\\x01\\x02" * random.randint(10, 100)  # Binary chaos
            ])
        else:  # EXTREME
            chaos_types = [
                # Memory bombs
                "X" * random.randint(10000, 100000),
                
                # Unicode chaos
                "".join([chr(random.randint(0, 65535)) for _ in range(random.randint(100, 1000))]),
                
                # Nested chaos
                json.dumps({"level_" + str(i): "data_" * random.randint(100, 500) for i in range(random.randint(10, 100))}),
                
                # SQL injection attempts
                "'; DROP TABLE users; --",
                "UNION SELECT * FROM sqlite_master",
                
                # Stack overflow attempts
                "(" * random.randint(1000, 5000) + ")" * random.randint(1000, 5000),
                
                # Regex bombs
                "a" * random.randint(1000, 5000) + "a?" * random.randint(100, 500),
                
                # Path traversal
                "../" * random.randint(50, 200) + "etc/passwd",
                
                # Format string attacks
                "%s" * random.randint(100, 500) + "%x" * random.randint(100, 500),
                
                # Buffer overflow simulation
                "AAAA" + "\\x41" * random.randint(1000, 5000),
                
                # Compression bombs (text)
                "0" * random.randint(50000, 200000),
                
                # Control character chaos
                "".join([chr(random.randint(0, 31)) for _ in range(random.randint(100, 500))]),
            ]
            
            return random.choice(chaos_types)

    def memory_bomb_test(self, bombs=50):
        """Test pamiƒôciowych bomb - pr√≥ba wyczerpania RAM"""
        print(f"\nüí£ MEMORY BOMB TEST - {bombs} bomb...")
        
        start_memory = psutil.Process().memory_info().rss / (1024 * 1024)
        bombs_detonated = 0
        
        for i in range(bombs):
            try:
                # Tw√≥rz ogromne dane
                chaos_data = self.generate_chaos_data("EXTREME")
                user_id = f"bomb_user_{random.randint(1, 5)}"
                
                # Pr√≥buj zapisaƒá w pamiƒôci hierarchicznej
                self.hm_system.process_new_memory(chaos_data, {"bomb": i}, user_id)
                
                bombs_detonated += 1
                
                # Sprawd≈∫ wykorzystanie pamiƒôci
                current_memory = psutil.Process().memory_info().rss / (1024 * 1024)
                self.results['max_memory_usage'] = max(self.results['max_memory_usage'], current_memory)
                
                if current_memory - start_memory > 500:  # 500MB wzrost
                    print(f"  üíÄ MEMORY LEAK DETECTED: {current_memory - start_memory:.1f}MB")
                    self.results['memory_leaks'].append({
                        'bomb': i,
                        'memory_increase': current_memory - start_memory,
                        'timestamp': time.time()
                    })
                
                if i % 10 == 0:
                    print(f"  üí£ {i}/{bombs} bomb detonated, RAM: {current_memory:.1f}MB")
                    
            except Exception as e:
                self.results['operations_failed'] += 1
                if "memory" in str(e).lower() or "overflow" in str(e).lower():
                    self.results['crashes'].append(f"Memory bomb {i}: {e}")
                    
        self.results['operations_completed'] += bombs_detonated
        end_memory = psutil.Process().memory_info().rss / (1024 * 1024)
        
        print(f"üí• MEMORY BOMBS: {bombs_detonated}/{bombs} detonated")
        print(f"üìä RAM: {start_memory:.1f}MB ‚Üí {end_memory:.1f}MB (+{end_memory-start_memory:.1f}MB)")

    def database_corruption_test(self):
        """Test pr√≥bujƒÖcy skorumpowaƒá bazƒô danych"""
        print(f"\nüíæüíÄ DATABASE CORRUPTION TEST...")
        
        corruption_attempts = [
            # SQL injection attempts
            "'; DROP TABLE hierarchical_episodes; --",
            "UNION SELECT sql FROM sqlite_master",
            
            # Binary chaos
            b'\x00\x01\x02\x03\x04\x05' * 1000,
            
            # Oversized data
            "CORRUPT" * 100000,
            
            # NULL byte injection
            "test\x00corruption\x00data",
            
            # Unicode exploitation
            "\uFEFF" * 1000 + "corruption_test",
        ]
        
        corruptions_attempted = 0
        corruptions_successful = 0
        
        for i, corruption in enumerate(corruption_attempts):
            try:
                user_id = f"corrupt_user_{i}"
                
                # Pr√≥buj zapisaƒá skorumpowane dane
                result = self.hm_system.process_new_memory(
                    str(corruption) if isinstance(corruption, bytes) else corruption, 
                    {"corruption_test": True}, 
                    user_id
                )
                
                corruptions_attempted += 1
                
                # Sprawd≈∫ czy baza nadal dzia≈Ça
                try:
                    test_query = self.hm_system.get_context_for_query(user_id, "test")
                    if not test_query:
                        print(f"  üíÄ POSSIBLE DATABASE CORRUPTION detected after attempt {i}")
                        corruptions_successful += 1
                        self.results['database_corruption'] = True
                except Exception as db_e:
                    print(f"  üî• DATABASE ERROR after corruption attempt {i}: {db_e}")
                    corruptions_successful += 1
                    self.results['database_corruption'] = True
                    
            except Exception as e:
                self.results['operations_failed'] += 1
                if "database" in str(e).lower() or "sqlite" in str(e).lower():
                    print(f"  üí• Database corruption attempt {i} caused: {e}")
                    corruptions_successful += 1
        
        self.results['operations_completed'] += corruptions_attempted
        print(f"üíæ DATABASE CORRUPTION: {corruptions_successful}/{len(corruption_attempts)} successful")

    def infinite_recursion_test(self):
        """Test niesko≈Ñczonej rekursji - pr√≥ba przepe≈Çnienia stosu"""
        print(f"\n‚ôæÔ∏èüíÄ INFINITE RECURSION TEST...")
        
        def recursive_chaos(depth=0, max_depth=10000):
            """Niesko≈Ñczona rekursja z chaosem"""
            if depth >= max_depth:
                return "MAX_DEPTH_REACHED"
                
            try:
                # Tw√≥rz chaos na ka≈ºdym poziomie
                chaos_data = self.generate_chaos_data("HEAVY")
                user_id = f"recursive_user_{depth % 10}"
                
                # Zapisz w pamiƒôci
                self.hm_system.process_new_memory(
                    f"Recursion level {depth}: {chaos_data[:100]}", 
                    {"recursion_depth": depth}, 
                    user_id
                )
                
                # Rekursywnie wywo≈Çaj siebie
                return recursive_chaos(depth + 1, max_depth)
                
            except RecursionError as re:
                print(f"  üíÄ RECURSION LIMIT HIT at depth {depth}")
                self.results['crashes'].append(f"Recursion limit: depth {depth}")
                return f"RECURSION_ERROR_AT_{depth}"
            except Exception as e:
                self.results['operations_failed'] += 1
                return f"ERROR_AT_{depth}: {e}"
        
        try:
            result = recursive_chaos()
            self.results['operations_completed'] += 1
            print(f"‚ôæÔ∏è RECURSION TEST: {result}")
        except Exception as e:
            print(f"üí• RECURSION TEST CRASHED: {e}")
            self.results['crashes'].append(f"Recursion test: {e}")

    def thread_bomb_test(self, threads=100, duration=30):
        """Test bomby wƒÖtkowej - pr√≥ba wyczerpania zasob√≥w systemowych"""
        print(f"\nüßµüí£ THREAD BOMB TEST - {threads} wƒÖtk√≥w przez {duration}s...")
        
        results_lock = threading.Lock()
        thread_operations = 0
        thread_crashes = 0
        active_threads = []
        
        def thread_chaos_worker(thread_id):
            nonlocal thread_operations, thread_crashes
            
            local_ops = 0
            local_crashes = 0
            end_time = time.time() + duration
            
            while time.time() < end_time:
                try:
                    operation_type = random.choice([
                        'memory_chaos', 'memory_chaos', 'memory_chaos',  # Wiƒôcej chaosu pamiƒôci
                        'cognitive_overload', 
                        'autonauka_spam',
                        'database_spam'
                    ])
                    
                    user_id = f"thread_{thread_id}_user_{random.randint(1, 5)}"
                    chaos_data = self.generate_chaos_data(random.choice(["HEAVY", "EXTREME"]))
                    
                    if operation_type == 'memory_chaos':
                        self.hm_system.process_new_memory(chaos_data, {"thread_chaos": thread_id}, user_id)
                        
                    elif operation_type == 'cognitive_overload':
                        self.cognitive.process_message(user_id, chaos_data, use_memory=True, use_hierarchical=True)
                        
                    elif operation_type == 'autonauka_spam':
                        if random.random() < 0.05:  # 5% szans - rzadko bo kosztowne
                            autonauka(chaos_data[:50], user_id, max_results=1)
                            
                    elif operation_type == 'database_spam':
                        context = self.hm_system.get_context_for_query(user_id, chaos_data[:100])
                    
                    local_ops += 1
                    
                    # Agresywne tempo - bez pauzy!
                    
                except Exception as e:
                    local_crashes += 1
                    
            with results_lock:
                thread_operations += local_ops
                thread_crashes += local_crashes
        
        # Uruchom bombƒô wƒÖtk√≥w!
        start_time = time.time()
        
        for i in range(threads):
            thread = threading.Thread(target=thread_chaos_worker, args=(i,), daemon=True)
            active_threads.append(thread)
            thread.start()
            
            # Mikro-pauza ≈ºeby nie zabiƒá systemu ca≈Çkowicie
            time.sleep(0.001)
        
        # Monitoruj CPU podczas testu
        cpu_samples = []
        def monitor_cpu():
            while time.time() < start_time + duration + 5:
                cpu_percent = psutil.cpu_percent(interval=1)
                cpu_samples.append(cpu_percent)
                self.results['max_cpu_usage'] = max(self.results['max_cpu_usage'], cpu_percent)
                
        cpu_monitor = threading.Thread(target=monitor_cpu, daemon=True)
        cpu_monitor.start()
        
        # Czekaj na zako≈Ñczenie
        for thread in active_threads:
            thread.join(timeout=duration + 10)
            
        actual_duration = time.time() - start_time
        
        self.results['operations_completed'] += thread_operations
        self.results['operations_failed'] += thread_crashes
        
        avg_cpu = sum(cpu_samples) / len(cpu_samples) if cpu_samples else 0
        
        print(f"üßµ THREAD BOMB: {thread_operations} operacji, {thread_crashes} crashy")
        print(f"‚ö° CPU: avg {avg_cpu:.1f}%, max {self.results['max_cpu_usage']:.1f}%")

    def system_recovery_test(self):
        """Test odzyskiwania systemu po ataku"""
        print(f"\nüîÑüíö SYSTEM RECOVERY TEST...")
        
        recovery_start = time.time()
        
        try:
            # Pr√≥buj oczyszczenie pamiƒôci
            gc.collect()
            
            # Test podstawowych funkcji
            test_user = "recovery_test_user"
            test_message = "System recovery test message"
            
            # Test pamiƒôci hierarchicznej
            recovery_result = self.hm_system.process_new_memory(
                test_message, 
                {"recovery_test": True}, 
                test_user
            )
            
            # Test cognitive engine
            cognitive_result = self.cognitive.process_message(
                test_user, 
                test_message, 
                use_memory=True,
                use_hierarchical=True
            )
            
            # Test kontekstu
            context_result = self.hm_system.get_context_for_query(test_user, test_message)
            
            recovery_time = time.time() - recovery_start
            self.results['system_recovery_time'] = recovery_time
            
            # Sprawd≈∫ czy system siƒô odzyska≈Ç
            if recovery_result and context_result:
                print(f"‚úÖ SYSTEM RECOVERED in {recovery_time:.2f}s")
                return True
            else:
                print(f"‚ùå SYSTEM FAILED TO RECOVER")
                return False
                
        except Exception as e:
            recovery_time = time.time() - recovery_start
            self.results['system_recovery_time'] = recovery_time
            print(f"üíÄ SYSTEM RECOVERY FAILED: {e}")
            self.results['crashes'].append(f"Recovery failed: {e}")
            return False

    def calculate_destruction_level(self):
        """Oblicza poziom zniszczenia systemu 0-100"""
        destruction = 0
        
        # Crashe (30 punkt√≥w max)
        destruction += min(len(self.results['crashes']) * 5, 30)
        
        # Memory leaks (20 punkt√≥w max)
        destruction += min(len(self.results['memory_leaks']) * 10, 20)
        
        # Database corruption (25 punkt√≥w max)
        if self.results['database_corruption']:
            destruction += 25
        
        # Failure rate (15 punkt√≥w max)
        total_ops = self.results['operations_completed'] + self.results['operations_failed']
        if total_ops > 0:
            failure_rate = self.results['operations_failed'] / total_ops
            destruction += min(failure_rate * 15, 15)
        
        # Recovery time (10 punkt√≥w max)
        if self.results['system_recovery_time'] > 10:
            destruction += 10
        elif self.results['system_recovery_time'] > 5:
            destruction += 5
        
        self.results['destruction_level'] = min(destruction, 100)
        return self.results['destruction_level']

    def run_ultra_extreme_test(self):
        """Uruchom ULTRA EKSTREMALNY test destrukcyjny! üíÄüî•"""
        
        print("üî•üíÄ" + "="*60 + "üíÄüî•")
        print("üí• ROZPOCZYNAM ULTRA EKSTREMALNE ROZPIERDALANIE SYSTEMU! üí•")
        print("üö® UWAGA: Test mo≈ºe uszkodziƒá system! üö®")
        print("üî•üíÄ" + "="*60 + "üíÄüî•")
        
        try:
            # Faza 1: Memory Bombs
            phase_start = time.time()
            self.memory_bomb_test(30)
            self.results['test_phases'].append({
                'phase': 'Memory Bombs',
                'duration': time.time() - phase_start,
                'status': 'completed'
            })
            
            # Faza 2: Database Corruption  
            phase_start = time.time()
            self.database_corruption_test()
            self.results['test_phases'].append({
                'phase': 'Database Corruption',
                'duration': time.time() - phase_start,
                'status': 'completed'
            })
            
            # Faza 3: Infinite Recursion
            phase_start = time.time()
            self.infinite_recursion_test()
            self.results['test_phases'].append({
                'phase': 'Infinite Recursion',
                'duration': time.time() - phase_start,
                'status': 'completed'
            })
            
            # Faza 4: Thread Bomb (NAJGRO≈πNIEJSZA)
            phase_start = time.time()
            self.thread_bomb_test(threads=50, duration=15)  # Mniej agresywne ≈ºeby nie zabiƒá systemu
            self.results['test_phases'].append({
                'phase': 'Thread Bomb',
                'duration': time.time() - phase_start,
                'status': 'completed'
            })
            
            # Faza 5: System Recovery
            phase_start = time.time()
            recovery_success = self.system_recovery_test()
            self.results['test_phases'].append({
                'phase': 'System Recovery',
                'duration': time.time() - phase_start,
                'status': 'success' if recovery_success else 'failed'
            })
            
        except KeyboardInterrupt:
            print("\nüõë TEST PRZERWANY PRZEZ U≈ªYTKOWNIKA!")
            self.results['crashes'].append("User interrupted")
        except Exception as e:
            print(f"\nüíÄ KRYTYCZNY CRASH PODCZAS TESTU: {e}")
            self.results['crashes'].append(f"Critical test crash: {e}")
            traceback.print_exc()
        
        # Oblicz poziom zniszczenia
        destruction_level = self.calculate_destruction_level()
        
        # Podsumowanie
        self.print_destruction_report(destruction_level)

    def print_destruction_report(self, destruction_level):
        """Wydrukuj raport zniszczenia systemu"""
        
        total_duration = time.time() - self.results['start_time']
        
        print("\n" + "üíÄüî•" + "="*60 + "üî•üíÄ")
        print("üí• RAPORT ZNISZCZENIA SYSTEMU üí•")
        print("üíÄüî•" + "="*60 + "üî•üíÄ")
        
        # Poziom zniszczenia
        print(f"\nüéØ POZIOM ZNISZCZENIA: {destruction_level:.1f}/100")
        
        if destruction_level < 20:
            print("‚úÖ SYSTEM PRZETRWA≈Å - Lekkie uszkodzenia")
        elif destruction_level < 40:
            print("‚ö†Ô∏è  SYSTEM USZKODZONY - ≈örednie zniszczenia")
        elif destruction_level < 70:
            print("üî• SYSTEM MOCNO USZKODZONY - Powa≈ºne problemy")
        else:
            print("üíÄ SYSTEM CA≈ÅKOWICIE ZNISZCZONY - Totalna destrukcja")
        
        # Statystyki operacji
        total_ops = self.results['operations_completed'] + self.results['operations_failed']
        success_rate = (self.results['operations_completed'] / total_ops * 100) if total_ops > 0 else 0
        
        print(f"\nüìä STATYSTYKI OPERACJI:")
        print(f"   ‚úÖ Uko≈Ñczone: {self.results['operations_completed']}")
        print(f"   ‚ùå Nieudane: {self.results['operations_failed']}")
        print(f"   üìà Sukces: {success_rate:.1f}%")
        
        # Crashe
        if self.results['crashes']:
            print(f"\nüí• CRASHE ({len(self.results['crashes'])}):")
            for i, crash in enumerate(self.results['crashes'][:5]):  # Top 5
                print(f"   {i+1}. {crash}")
            if len(self.results['crashes']) > 5:
                print(f"   ... i {len(self.results['crashes']) - 5} wiƒôcej")
        
        # Memory leaks
        if self.results['memory_leaks']:
            print(f"\nüß† MEMORY LEAKS ({len(self.results['memory_leaks'])}):")
            for leak in self.results['memory_leaks'][:3]:
                print(f"   üíß Bomb {leak['bomb']}: +{leak['memory_increase']:.1f}MB")
        
        # Database corruption
        if self.results['database_corruption']:
            print(f"\nüíæ DATABASE CORRUPTION: ‚ùå DETECTED")
        else:
            print(f"\nüíæ DATABASE CORRUPTION: ‚úÖ None detected")
        
        # System resources
        print(f"\n‚ö° ZASOBY SYSTEMOWE:")
        print(f"   üß† Max RAM: {self.results['max_memory_usage']:.1f}MB")
        print(f"   üî• Max CPU: {self.results['max_cpu_usage']:.1f}%")
        print(f"   üîÑ Recovery time: {self.results['system_recovery_time']:.2f}s")
        
        # Fazy test√≥w
        print(f"\nüîÑ FAZY TEST√ìW:")
        for phase in self.results['test_phases']:
            status_icon = "‚úÖ" if phase['status'] == 'completed' else "‚ùå" if phase['status'] == 'failed' else "‚ö†Ô∏è"
            print(f"   {status_icon} {phase['phase']}: {phase['duration']:.1f}s")
        
        print(f"\n‚è±Ô∏è  CZAS TOTALNY: {total_duration:.1f}s")
        
        # Werdykt ko≈Ñcowy
        print(f"\n" + "üé≠ WERDYKT KO≈ÉCOWY üé≠")
        if destruction_level >= 80:
            print("üíÄ MISSION ACCOMPLISHED - SYSTEM ZOSTA≈Å ROZPIERDALONY!")
        elif destruction_level >= 60:
            print("üî• GOOD JOB - System mocno zniszczony!")
        elif destruction_level >= 40:
            print("‚ö†Ô∏è  NOT BAD - System uszkodzony, ale wytrzyma≈Ç")
        else:
            print("üò§ SYSTEM TOO STRONG - Potrzeba wiƒôcej si≈Çy!")
        
        print("üíÄüî•" + "="*60 + "üî•üíÄ")
        
        # Zapisz wyniki
        with open('ultra_destruction_report.json', 'w', encoding='utf-8') as f:
            json.dump(self.results, f, indent=2, ensure_ascii=False, default=str)
        
        print("üíæ Raport zniszczenia zapisany do: ultra_destruction_report.json")

if __name__ == "__main__":
    print("üíÄüî• ULTRA EXTREME DESTRUCTION TEST üî•üíÄ")
    print("‚ö†Ô∏è  UWAGA: Ten test mo≈ºe nieodwracalnie uszkodziƒá system!")
    print("Naci≈õnij Ctrl+C aby przerwaƒá w dowolnym momencie")
    print()
    
    # Ostrze≈ºenie
    confirmation = input("üö® Czy naprawdƒô chcesz rozpierdaliƒá system? (wpisz 'DESTROY'): ")
    if confirmation != "DESTROY":
        print("‚ùå Test anulowany. MƒÖdra decyzja!")
        sys.exit(0)
    
    print("\nüí• ROZPOCZYNAM DESTRUKCJƒò W 3... 2... 1... üí•")
    time.sleep(3)
    
    try:
        destroyer = UltraExtremeStressTest()
        destroyer.run_ultra_extreme_test()
    except KeyboardInterrupt:
        print("\nüõë DESTRUKCJA ZATRZYMANA PRZEZ U≈ªYTKOWNIKA")
    except Exception as e:
        print(f"\nüíÄ KRYTYCZNY B≈ÅƒÑD DESTRUCTORA: {e}")
        traceback.print_exc()